---
title: "<FONT color='#0066CC'><FONT size = 4 ><DIV align= center> AP-4209 ESIEE-Paris: 2023 -2024 </DIV></FONT></FONT>"
output:
    html_document:
      highlight: textmate #,, , , espresso, , , , and  default  tango  pygments monochrome  kate zenburn haddock  
      theme:   readable  # , , flatly, , , spacelab, united, cosmo, lumen, paper, sandstone, simplex,  yeti default cerulean journal    darkl    
      toc: yes
      toc_depth: 6
      toc_float: true
---

```{=html}
<style type="text/css">
body, td {font-size: 17px;}
code.r{font-size: 5px;}
pre { font-size: 15px;}
</style>
```
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<FONT color='#0066CC'><FONT size = 4 >

::: {align="center"}
Fouille de données avec R pour la data science et l'intelligence artificielle\ 

--TD 1: Rappels--
:::

</FONT></FONT>

<FONT color='#0066CC'><FONT size = 4 >

::: {align="center"}
Badr TAJINI -- ESIEE Paris\
Source : Bertrand Roudier -- ESIEE Paris
:::

</FONT></FONT>

<hr style="border: 1px  solid gray">

</hr>

ce TD a pour objectif de rappeler l'utilisation des dataframes et des listes en R

<hr style="border: 1px  solid gray">

#### <FONT color='#000033'> 1. Dataframes  </FONT>
Ce chapitre a pour objectif de rappeler les principales fonctions permettant de manipuler les data frames et les listes qui nous serviront tout au long de ce module. il ne s'agit donc pas d'une description exhaustive.
Nous aborderons aussi les tables qui seront utilisées plus spécifiquement pour la classification bayésienne.

##### <FONT color='#000033'><FONT size = 3>  1.1 Création  </FONT></FONT>

  - on simule 4 vecteurs. 
      *  2 vecteurs simulent une distribution normale (var_1, var_2)
      *  1 vecteur simule une distribution uniforme (var_3)
      *  1 vecteur simule une variable binaire (var_4)
    
```{r}
rm(list = ls())
library(kableExtra)
#- > on fixe la graine
set.seed(128943)
#-> simulation d'une distribution normale (vecteurs)
var_1 <- rnorm(100,0,4)
var_2 <- rnorm(100,3,6)
#-> simulation d'une distribution uniforme (vecteurs)
var_3 <- runif(100, min = 6, max = 10)
```

* Simulation d'une variable binaire
    - on simule une distribution uniforme avec min = 0 et max = 1 
    - on fixe un seuil si x <= 0.5 alors x =0 sinon x = 1
    
* Pour y parvenir :
    - On génère un vecteur contenant 100 éléments tous égaux à 100 (*rep*)
    - On simule la distribution uniforme  (*runif*)
    - On fixe un seuil = 0.5 et l'on récupère les identifiants (id) > seuil  (*which*)
    - On affecte aux éléments (id) du vecteur la valaur 1
    
```{r}
# méthode 1 (élégante)
seuil <- 0.5
var_4 <- ifelse(runif(100,min = 0, max = 1) <= seuil, 1, 0)

# méthode 2 (plus standard)
var_4     <- rep(0,100)
id        <- which(runif(100,min = 0, max = 1) > seuil)
var_4[id] <- 1 

```

* Création du dataframe à partir des vecteurs

```{r}
df_1 <- data.frame('A' = var_1,
                   'B' = var_2,
                   'C' = var_3,
                   'D' = var_4)
# pour rappel
#ncol(df_1) # nombre colonnnes 
#nrow(df_1) # nombre de lignes
```

```{r, echo=F}
df_1 %>% kbl(digits=3) %>%  kable_styling(bootstrap_options = "striped", full_width = F, position = "center", latex_options = 'stripped') %>% scroll_box( height = "250px")
```

* factorisation d'une variable
  - la variable binaire est factorisée et les labels sont transformés : 0 devient 'NON' et 1 devient 'OUI'
    * On selectionne la variable  avec un pointeur explicite (*$*) (equivalent à *.* en python)
```{r}
df_1$D <- factor(df_1$D , levels = c(0,1), labels = c('Oui','Non'))
```

* On vérifie que la variable D est bien factorielle (eq. catégorielle en R)

```{r}
class(df_1$D)
```


* On peut affecter des noms aux instances (lignes) du dataframe : Par exemple, à chaque ligne 

```{r}
row.names(df_1) <- paste0('Patient_',1:100)

```

* le data frame est maintenant le suivant

```{r, echo = F}
df_1 %>% kbl(digits=3) %>%  kable_styling(bootstrap_options = "striped", full_width = F, position = "center", latex_options = 'stripped') %>% scroll_box( height = "250px")
```

<br>

<hr>

##### <FONT color='#000033'><FONT size = 3>  1.2 Extraction variables  </FONT></FONT>

* Sélection des colonnes à partir des index
```{r}
# extraction à partir des index
# attention si extractiuon d'une seule variable, le résultat est un vecteur
v_2 <- df_1[,3]
# extraction des variables A et D (le résultat est un dataframe)
df_3 <- df_1[,c(1,3)]
class(df_3)
```
* Sélection des colonnes à partir des pointeurs
    - une seule variable : le résultats est un vecteur
    - pour extraire plusieurs variables, on crée un nouveau dataframe
```{r}
# une seule variable
v_3 <- df_1$A
# plusieurs variables
df_5 <- data.frame(df_1$A, df_1$D)

```

* Sélection des colonnes à partir des noms des variables
```{r}
df_6 <- df_1[c('A','D')]
```

##### <FONT color='#000033'><FONT size = 3>  1.3 Extraction des lignes  </FONT></FONT>

* Sélection des colonnes à partir des index des lignes

```{r}
# sélection de la ligne 53 le résultat est un dataframe !
df_7 <- df_1[53,] 

# sélection des la lignes 11 à 15, 38 , 40, de 70, 72, 74 , 76, 78, 80 le résultats est un dataframe !
df_8 <- df_1[c (11:15, 38,40, seq(70,80,2)), ]
```


* Sélection des colonnes à partir des nom des lignes (s'ils existent)
```{r}
# Sélection des patients 25, 28,74
df_9 <- df_1[c('Patient_25','Patient_28','Patient_74'), ]
```

##### <FONT color='#000033'><FONT size = 3>  1.3 Extraction lignes / colonnes  </FONT></FONT>
* Sélection des lignes et des colonnes en fonction des index

```{r}
# extraire les patients 11 à 15, 38 , 40, de 70, 72, 74 , 76, 78, 80 pour les variables A et D
df_10 <- df_1[c (11:15, 38,40, seq(70,80,2)), c(1,4)]

```

* Sélection des lignes et des colonnes en fonction des noms

```{r}
# Sélection des patients 25, 28,74 pour les variables A et C
df_11 <- df_1[c('Patient_25','Patient_28','Patient_74'),c('A','C') ]
```

##### <FONT color='#000033'><FONT size = 3>  1.4 Sélection  </FONT></FONT>

* Sélection des patients avec A > 0.3
```{r}
df_12 <- df_1[ df_1$A > 0, ]
```

* Sélection des patients avec A > 0.3 et B  < 2 

```{r}
df_13 <- df_1[df_1$A > 0.3 & df_1$B < 2 ,]
```

* Sélection des patients avec A > 0.3 et B  < 2 et D = Oui
```{r}
df_14 <- df_1[df_1$A > 0.3 & df_1$B < 2 & df_1$D == 'Oui' ,]
```

* Sélection des patients avec A > 0.3 et B  < 2  et D = Oui et extraction des variables B et D
```{r}
df_14 <- df_1[df_1$A > 0.3 & df_1$B < 2 & df_1$D == 'Oui' , c('B','D')]
```

* On peut aussi utiliser la fonction subset :
  - Sélection des patients tel que A > 0.3 et B  < 2  et D = Oui et extraction des variables B et D

```{r}
df_15 <- subset(df_1, A > 0.3 & B < 2 & D == 'Oui', select = c(B,D))
```

##### <FONT color='#000033'><FONT size = 3>  1.5 Application de fonctions  </FONT></FONT>

* la fonctions *apply* permet d'appliquer des fonctions par ligne ou par colonn
  - Calcul de la moyenne : Attention, il faut ne pas prendre en compte la variable factorielle !
     -  par ligne   : MARGIN = 1 
     -  par colonne : MARGIN = 2 

```{r}
# moyenne par colonne margin = 2
s1 <- apply(df_1[, -4], MARGIN = 1, mean)

# moyenne par colonne margin = 2
s2 <- apply(df_1[, -4], MARGIN = 2, mean)

```

* On peut aussi utiliser la fonction *sapply* qui réalise automatiquement les calculs par colonnes

```{r}
s2 <- sapply(df_1[, -4], mean)
```

* Il est aussi possible de définir sa propre fonction. Dans notre cas nous voulons calculer le coefficient de variation CV% = écart type / moyenne *100. Pour y parvenir, nous avons deux possibilités d'implémentation

```{r}
# utilisation d'une fonction externe
cv <- function(x){return(sd(x, na.rm = T) / mean(x, na.rm = T) *100 )}
s3 <- sapply(df_1[-4], FUN = cv)

# utilisation d'une fonction interne
s5 <- sapply(df_1[-4], function(x){return(sd(x, na.rm = T) / mean(x, na.rm = T) *100 )})
```

* Une autre fonction qui sera (très) utilisée dans le module est la fonction *lapply*. elle agit comme les fonction *sapply* et *apply* mais les résultats sont stockés spécifiquement sous forme d'une liste (cf. chap II)

```{r}
cv <- function(x){return(sd(x, na.rm = T) / mean(x, na.rm = T) *100 )}
s4 <- lapply(df_1[-4], FUN = cv)
s4

```




##### <FONT color='#000033'><FONT size = 3>  1.6 Aggrégation  </FONT></FONT>

* Nous cherchons à calculer les moyennes de A,B,C par niveau de facteur de la variable catégorielle D. Pour y parvenir, nous utilisons la fonction *aggregate*

```{r}
ag_1 <- aggregate(df_1[-4], by = list(df_1$D), mean)

```

* de manière identique à la fonction *sapply* ou *apply*, on peut définir une fonction particulière (ici calcul des CV %) :

```{r}
ag_2 <- aggregate(df_1[-4], by = list(df_1$D), function(x){return(sd(x, na.rm = T) / mean(x, na.rm = T) *100 )})
```

##### <FONT color='#000033'><FONT size = 3>  1.7 Concaténation  </FONT></FONT>

* On peut effectuer une concaténation de deux data frames en ligne ou en colonne

```{r}
# concaténation en colonnes
# On crée deux dataFrame
df_AB <- data.frame('A' = var_1,'B' = var_2)
df_BC <- data.frame('C' = var_3,'D' = var_4)
df_ABCD <- cbind(df_AB, df_BC)

# concaténation en ligne
df_1_50   <- df_1[1:50,]
df_51_100 <- df_1[51:100,]
df_1_100 <- rbind(df_1_50, df_51_100)
# attention il est nécessaire les noms des variables soient identiques sinon cela ne fonctionne pas !

```

##### <FONT color='#000033'><FONT size = 3>  1.8 Utilitaires  </FONT></FONT>

Dans ce paragraphe, nous décrivons quelques fonctions utiles qui vous serviront pour ce module

* modifier les nom des variables d'un dataframe
```{r}
# modifier tous les noms 
names(df_1) <- c('VAR_1','VAR_2','VAR_3','VAR_4')

# modifier le nom de la 3 ième variable
names(df_1)[3] <- 'VAR_999'
```

* recherche le type de variable dans un data frame (retourne l'identifiant de la colonne)
 
```{r}
# variable numériques
id_num <- which(sapply(df_1, is.numeric))
# puis les extraire 
df_num <- df_1[,id_num]

# variable catégorielle
id_cat <- which(sapply(df_1, is.factor))
# puis l'extraire (attention sous forme de vecteur puisqu'une seule variables !)
df_cat <- df_1[,id_cat] 

```

hr style="border: 1px  solid gray">

#### <FONT color='#000033'> 2. Listes  </FONT>

La liste est un objet hétérogène. Il est composé d'un ensemble (ordonnée) d'éléments, ces derniers pouvant être différents (matrice, dataframe, ....).

##### <FONT color='#000033'> 2.1 Création d'une liste  </FONT>

```{r}
vecteur <- seq(2,10,by=3)
matrice <- matrix(1:8,ncol=2)
facteur <- factor(c("M","M","F","M","F","M","M","M"))
ordonne <- ordered(c("débutant","débutant","champion",
                     "champion","moyen","moyen","moyen","champion"),
                   levels=c("débutant","moyen","champion"))
mylist <- list(vecteur,matrice,facteur,ordonne)
mylist
```
* extraction d'un élément de la liste(second élément). On utilise les doubles crochets

```{r}
mat <- mylist[[2]]
mat
```

* On peut affecter un nom à chaque élément de la liste
```{r}
names(mylist)[[1]] <- 'vecteur'
names(mylist)[[2]] <- 'matrice'
names(mylist)[[3]] <- 'facteur'
names(mylist)[[4]] <- 'ordre'
mylist
```

* On peut ainsi directement accéder à un élément de la liste par son nom en utilisant le pointeur explicite *$*

```{r}
mylist$vecteur
```

* On peut ajouter un nouvel élément  que nous appelons *rand* à la liste

```{r}
r <-  runif(10, min = 3, max = 12)
mylist[['rand']] <- r
mylist

```


* De manière générale, il est plus facile, lorsque cela est possible, de déclarer un nom pour chaque élément de la liste. Pour cela, il suffit d'écrire :
```{r}
# pour l'exemple nous créons la même liste que précédemment mais en prenant de nousveau nom
mylist2 <- list('L_1' =  vecteur, 'L_2' = matrice, 'L_3' = facteur, 'L_4' = ordonne)
```

* On peut aussi créer une liste de manière dynamique (important pour la suite du TP)
```{r}
# on crée une liste vide
mylist3 <- list()
#... que l'on remplit progressivement
mylist3[['A']] <-  seq(2,10,by=3)
mylist3[['B']] <-  matrix(1:8,ncol=2)
mylist3[['C']] <-  factor(c("M","M","F","M","F","M","M","M"))
mylist3[['D']] <-  ordered(c("débutant","débutant","champion",
                     "champion","moyen","moyen","moyen","champion"),
                   levels=c("débutant","moyen","champion"))



```


* On peut aussi transformer un dataframe en une liste en utilisant la fonction *as.list*

```{r}
mylist4 <- as.list(df_1)
names(mylist4)
```






##### <FONT color='#000033'> 2.2 Extraction des éléments  </FONT>

* extraction d'une élément. Nous voulons: 
    - extraire l'élément "matrice"
    - transformer cette matrice en un dataframe
    - affecter des noms aux colonnes (A et B) et aux lignes du dataframe (P_1 à P_4)
    - intégrer ce dataframe à la liste sous le nom "mydata" et effacer de la liste l'élément "matrice" 

```{r}
# extraction
mat <- mylist$matrice
# conversion
df <- data.frame(mat)
# affectation des noms lignes et colonnes
names(df) <- c('A','B') ; rownames(df) <- paste0('P_',1:nrow(df) )
# intégrer dans le dataframe dans la liste
mylist[['mydata']] <- df
# effacer l'élément matrice
mylist$matrice <- NULL

mylist
```

* extraction d'un sous élément . Nous voulons 
  extraire les secondes et troisième ligne de la colonne B du dataframe "mydata"

```{r}
res1 <- mylist$mydata[c(2:4),2]
# ou bien
res2 <- mylist[['mydata']][c(2:4),2]
# ou bien
res3 <- mylist[['mydata']][c('P_2','P_3','P_4'),c('B')]
# les résultats ont identiques


```
  
##### <FONT color='#000033'> 2.3 Sélection des éléments  </FONT>

* Nous pouvons sélectionner des sous éléments avec des fonctions comme nous l'avons vu avec les dataframes. Par exemple nous voulons calculer le nombre de 'M' dans la variable "facteur"


```{r}
n <- length(mylist[['facteur']] == 'M') ; n
```

* Nous voulons sélectionner les valeurs > 6 de l'élément "matrice" sur la colonne B

```{r}
# l'écriture est un peu plus compliquée;  attention à bien positionner les crochets !
temp <- mylist[['mydata']][ mylist[['mydata']]$B > 6,] ; temp

```



hr style="border: 1px  solid gray">

#### <FONT color='#000033'> 3. Tables  </FONT>

##### <FONT color='#000033'> 3.1 Dénombrement  </FONT>

* Lorsque nous sommes en présence ds variables catégorielles, il est souvent utile de réaliser un dénombrement des différents niveau de facteur. Dans un premier temps nous créons un dataframe composé de deux variables catégorielles. La fonction *table* permet d'effectuer le dénombrement et la fonction *prop.table* calcule les proportions correspondantes

```{r}
set.seed(1234)
var_6 <- ifelse(runif(100,min = 0, max = 1) <= 0.5 , 1, 0)
var_7 <- ifelse(runif(100,min = 10, max = 50) <= 35, 0, 1)

df_cat <- data.frame('Diag'    = factor(var_6, levels = c(0,1), labels = c('OUI','NON' )),
                     'Statut'  = factor(var_7, levels = c(1,0), labels = c('M','NM' ))
                    )

# dénombrent variable Diag
table(df_cat$Diag)
# proportions correspondantes
prop.table(table(df_cat$Diag))

# dénombrent variable Statut
table(df_cat$Statut)
# proportions correspondantes
prop.table(table(df_cat$Statut))

```

##### <FONT color='#000033'> 3.2 Croisement de deux variables  </FONT>
Le croisement de deux variables catégorielles permet de calculer le nombre d'observations pour chaque niveau de facteur des deux variables 
```{r}
table(df_cat$Diag, df_cat$Statut )
# calcul en fréquence
prop.table(table(df_cat$Diag, df_cat$Statut ))

```

Avec la fonction *prop.table*, nous spécifierons une valeur pour l'argument "margin". Si margin = 1, alors la fonction retourne les profils lignes. A titre d'exemple, pour chaque cellules les proportions seront calculées comme suit: 

  * cellule(OUI,M)  = 16 /(29 + 16)  
  * cellule(OUI,MN) = 29 /(29 + 16)  
  * cellule(NON,M)  = 24 /(24 + 31)  
  * cellule(NON,M)  = 31 /(22 + 31)  

```{r}
prop.table(table(df_cat$Diag, df_cat$Statut), margin = 1)
```

* On peut extraire un élément pas son nom au sein d'une table, par exemple extraire la valeur de la cellule ('OUI','M')
```{r}

tab <- prop.table(table(df_cat$Diag, df_cat$Statut ))
tab['OUI','M']
```

